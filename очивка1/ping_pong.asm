;======================================  
; Переписанный код для ATmega8  
;======================================  
.include "m8def.inc"   ; Подключаем определения для ATmega8  

.def temp_reg   = r16  
.def temp_reg2  = r17  
.def isr_source  = r18  

;--------------------------------------  
; Строковые данные  
ping_msg:              ; Строка "ping\r\n"  
    .db "ping\r\n", 0  

pong_msg:              ; Строка "pong\r\n"  
    .db "pong\r\n", 0  

;--------------------------------------  
; Общий обработчик прерываний  
COMMON_ISR:            ; Начало общего обработчика прерываний  
    push temp_reg      
    push temp_reg2     
    push isr_source    
    push r24          
    push r25          
    push ZH           
    push ZL           

    in temp_reg, TIFR  ; Чтение регистра флагов прерываний  
    sbrc temp_reg, OCF2 ; Проверка флага прерывания от таймера 2  
    ldi isr_source, 0x01 ; Установка источника прерывания для таймера 2  
    sbrs temp_reg, OCF2 
    sbrc temp_reg, OCF1A ; Проверка флага прерывания от таймера 1  
    ldi isr_source, 0x02 ; Установка источника прерывания для таймера 1  

    out TIFR, temp_reg  ; Сброс флагов прерывания  

    cpi isr_source, 0x02 ; Если источник - таймер 1, переход к обработчику таймера 1  
    breq TIMER1_HANDLER  
    cpi isr_source, 0x01 ; Если источник - таймер 2, переход к обработчику таймера 2  
    breq TIMER2_HANDLER  
    rjmp COMMON_ISR_END   ; Если источник не определен, переход к концу  

TIMER1_HANDLER:        ; Обработчик прерывания от таймера 1  
    ldi r24, high(ping_msg*2) ; Загружаем старший байт адреса строки ping_msg в Z  
    ldi r25, low(ping_msg*2)  ; Загружаем младший байт адреса строки ping_msg в Z  
    mov ZH, r24          ; Устанавливаем старший байт регистра Z  
    mov ZL, r25          ; Устанавливаем младший байт регистра Z  
    rcall send_string    ; Вызов функции отправки строки  
    rjmp COMMON_ISR_END  ; Переход к концу обработчика  

TIMER2_HANDLER:        ; Обработчик прерывания от таймера 2  
    ldi r24, high(pong_msg*2) ; Загружаем старший байт адреса строки pong_msg в Z  
    ldi r25, low(pong_msg*2)  ; Загружаем младший байт адреса строки pong_msg в Z  
    mov ZH, r24          ; Устанавливаем старший байт регистра Z  
    mov ZL, r25          ; Устанавливаем младший байт регистра Z  
    rcall send_string    ; Вызов функции отправки строки  

COMMON_ISR_END:        ; Конец общего обработчика прерываний  
    pop ZL              ; Восстанавливаем младший байт Z  
    pop ZH              ; Восстанавливаем старший байт Z  
    pop r25             ; Восстанавливаем r25  
    pop r24             ; Восстанавливаем r24  
    pop isr_source      ; Восстанавливаем источник прерывания  
    pop temp_reg2       ; Восстанавливаем временные регистры  
    pop temp_reg        ; Восстанавливаем временный регистр  
    reti                ; Возврат из прерывания  

;--------------------------------------  
; Функция отправки байта через USART
send_char:  
    sbis UCSRA, UDRE      ; Ожидание готовности буфера передачи  
    rjmp send_char        ; Повторяем ожидание, если буфер занят  
    out UDR, r24          ; Отправка байта из r24  
    ret  

send_string:            ; Функция для отправки строки  
next_char:             
    lpm r24, Z+          ; Загружаем байт из строки с постинкрементом   
    tst r24              ; Проверяем конец строки (нулевой байт)  
    breq done_string     ; Если ноль - заканчиваем отправку строки  
    rcall send_char      ; Отправка байта через USART  
    rjmp next_char       ; Переход к следующему байту  

done_string:            ; Конец отправки строки  
    ret  
